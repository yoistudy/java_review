#Ch15 네트워킹

##1. 네트워킹(Networking)
네트워킹이란 두 대 이상의 컴퓨터를 케이블로 연결하여 네트워크를 구성하는 것을 말한다.
자바에서 제공하는 java.net패키지를 사용하면 이러한 네트워크 어플리케이션의 데이터 통신 부분을
쉽게 작성할 수 있으며, 간단한 네트워크 어플리케이션은 단 몇줄의 자바코드만으로 작성이 가능하다.

###1.1 클라이언트/서버(client/server)
서버는 서비스를 제공하는 컴퓨터이고, 클라이언트는 서비스를 사용하는 컴퓨터

서비스는 서버가 클라이언트로부터 요청받은 작업을 처리하여 그 결과를 제공하는 것을 뜻하며
서버가 제공하는 서비스의 종류에 따라 파일서버, 메일서버, 어플리케이션서버 등이 있다.

전용서버를 두는 것을 서버기반모델
전용서버없이 각 클라이언트가 서버역할을 동시에 수행하는 것을 P2P모델

| 서버기반모델(server-based model) | P2P 모델(peer-to-peer model) |
|--------|--------|
| -안정적인 서비스의 제공이 가능하다.<br/> -공유데이터의 관리와 보안이 용이하다.<br/> -서버구축비용과 관리비용이 든다.  | -서버구축 및 운용비용을 절감할 수 있다 <br/> -자원의 활용을 극대화 할 수있다.</br> -자원의 관리가 어렵다.</br> -보안이 취약하다.     |

###1.2 IP주소(IP address)
IP주소는 컴퓨터를 구별하는데 사용되는 고유한 값으로 인터넷에 연결된 모든 컴퓨터는 IP주소를 갖는다.
IP주소는 4byte(32bit)의 정수로 구성되어 있으며, 4개의 정수가 마침표를 구분자로 'a.b.c.d'와 같은 형식으로 표현된다. 여기서 a,b,c,d는 부호없는 1byte값, 0~255사이의 정수이다.

IP주소는 네트워크주소와 호스트주소로 나눌 수 있다.
32bit의 IP중에서 네트워크주소와 호스트주소가 각각 몇 bit를 차지하는 지는 네트워크를 어떻게 구성하였는지에 따라 달라진다.
서로 다른 두 호스트의 IP주소의 네트워크주소가 같다는 것은 두 호스트가 같은 네트워크에 포함되어 있다는 것을 의미한다.

IP주소와 서브넷 마스크를 '&'연산하면 네트워크 주소를 얻어낼 수 있어서
서로 다른 두 호스트의 IP주소를 서브넷 마스크로 '&'연산을 수행해서 비교하면
이 두 호스트가 같은 네티워크 상에 존재하는지를 쉽게 확인할 수 있다.[그림15-2 p-907]

###1.3 InetAddress
자바에서는 IP주소를 다루기 위한 클래스로 InetAddress를 제공하며 메서드가 정의되어 있다.
[표 15-2 p-907] [예제 15-1 p-908]

###1.4 URL(Unoform Resource Location)
URL은 인터넷에 존재하는 여러 서버들이 제공하는 자원에 접긍할 수 있는 주소를 표현하기 위한 것으로
'프로토콜://호스트명:포트번호/경로명/파일명?쿼리스트링#참조'의 형태로 이루어져 있다.
[참고]URL에서 포트번호, 쿼리, 참조는 생략할 수 있다.

	http://www.javachobo.com:80/sample/hello.html?referer=javachobo#index1
    프로토콜 : 자원에 접근하기 위해 서버와 통신하는데 사용되는 통신규약(http)
    호스트명 : 자원을 제공하는 서버의 이름(www.javachobo.com)
    포트번호 : 통신에 사용되는 서버의 포트번호(80)
    경로명  : 접근하려는 자원이 저장된 서버상의 위치(/sample/)
    파일명  : 접근하려는 자원의 이름(hello.html)
    쿼리(query) : URL에서  '?'이후의 부분(refer=javachobo)
	참조(anchor) : URL에서 '#'이후의 부분(index1)

[참고]HTTP프로토콜에서는 80번 포트를 사용하기 때문에 URL에서 포트번호를 생략하는 경우 80으로 간주
각 프로토콜에 따라 통신에 사용하는 포트번호가 다르며 생략되면 각 프로토콜의 기본 포트가 사용된다.

자바에서는 URL을 다루기 위한 클래스로 URL클래스를 제공하며 메서드가 정의되어 있다.
[표 15-3 p-910] [예제 15-2 p-911]

###1.5 URLConnection
URLConnection은 어플리케이션과 URL간의 통신연결을 나타내는 클래스의 최상위 클래스로 추상클래스
URLConnection을 사용해서 연결하고자하는 자원에 접근하고 읽고 쓰기를 할 수 있다.
그 외에 관련된 정보를 읽고 쓸 수 있는 메서드가 제공된다.[표 15-4 p-912] [예제 15-3 p-913]

만일 URL이 유효하지 않으면 Malformed-URLException이 발생한다.

##2. 소켓 프로그래밍
소켓이란 프로세스간의 통신에 사용되는 양쪽 끝단을 의미한다.
자바에서는 java.net패키지를 통해 소켓 프로그래밍을 지원하는데,
소켓통신에 사용되는 프로토콜에 따라 다른 종류의 소켓을 구현하여 제공한다.

###2.1 TCP와 UDP
TCP/IP 프로토콜은 이기종 시스템간의 통신을 위한 표준 프로토콜로 프로토콜의 집합이다.
TCP와 UDP는 모두 TCP/IP 프로토콜에 포함되어 있으며, OSI 7계층의 전송계층에 해당하는 프로토콜이다.

TCP와 UDP는 전송 방식이 다르며, 각 방식에 따른 장단점이 있다.
어플리케이션의 특징에 따라 적절한 프로토콜을 선택하여 사용하도록 하자.

| 항목| TCP | UDP |
|--------|--------|--------|
|연결방식|연결기반(connection-oriented)<br/>-연결 후 통신(전화)<br/>-1:1 통신방식|비연결기반(connectionless-oriented)<br/>-연결없이 통신(소포)<br/>-1:1, 1:n, n:n 통신방식 |
|특징|데이터의 경계를 구분안함<br/> -데이터의 전송순서가 보장됨<br/>신뢰성 있는 데이터 전송<br/>-데이터의 수신여부를 확인함<br/>(데이터가 손실되면 재전송)<br/>-패킷을 관리할 필요가 없음<br/>UDP보다 전송속도가 느림  | 데이터의 경계를 구분함<br/>신뢰성 없는 데이터 전송<br/>-데이터의 전송순서가 바뀔 수 있음<br/>-데이터의 수신여부를 확인 안함<br/>(데이터가 손실되어도 알 수 없음)<br/>-패킷을 관리해주어야 함<br/>TCP보다 전송속도가 빠름|
|관련 클래스| Socket <br/>ServerSocket |DatagramSocket<br/>DatagramPacket<br/>MulticastSocket |

###2.2 TCP소켓 프로그래밍
TCP소켓 프로그래밍은 클라이언트와 서버간의 일대일 통신이다.
먼저 서버프로그램이 실행되어 클라이언트 프로그램의 연결요청을 기다리고 있어야한다.

서버 프로그램과 클라이언트 프로그램간의 통신과정 단계

    1.서버 프로그램에서는 서버소켓을 사용해서 서버 컴퓨터의 특정 포트에서
      클라이언트의 연결요청을 처리할 준비를 한다.
    2.클라이언트 프로그램은 접속할 서버의 IP주소와 포트 정보를 가지고
      소켓을 생성해서 서버에 연결을 요청한다.
    3.서버소켓은 클라이언트의 연결요청을 받으면 서버에 새로운 소켓을 생성해서
      클라이언트의 소켓과 연결되도록 한다.
    4.클라이언트의 소켓과 새로 생성된 서버의 소켓은 서버소켓과 관계없이 일대일 통신을 한다.

서버소켓은 소켓간의 연결만 처리하고 실제 데이터는 소켓들끼리 서로 주고 받는다.
소켓들이 데이터를 주고받는 연결통로는 바로 입출력스트림이다.

소켓은 두 개의 스트림, 입력스트립과 출력스트림을 가지고 있으며,
이 스트림들은 연결된 상대편 소켓의 스트림들과 교차연결된다.
한 소켓의 입력스트림은 상대편 소켓의 출력 스트림으로 연결되고, 출력스트림은 입력스트림과 연결된다.

자바에서 TCP를 이용한 소켓프로그래밍을 위한 Socket과 ServerSocket클래스의 특징

	Socket - 프로세스간의 통신을 담당하며, InputStream과 OutputStream을 가지고 있다.
    		 이 두 스트림을 통해 프로세스간의 통신(입출력)이 이루어진다.
    ServerSocket - 포트와 연결되어 외부의 연결요청을 기다리다 연결요청이 들어오면,
    			   Socket을 새성해서 소켓과 소켓간의 통신이 이루어지도록 한다.
                   한 포트에 하나의 ServerSocket만 연결할 수 있다.
                   (프로토콜이 다르면 같은 포트를 공유할 수 있다.)

간단한 TCP/IP서버 구현 예제 [예제 15-6 p-919][예제 15-7 p-920]

서버프로그램이 실행되고 있지 않거나 서버의 전원이 꺼져있어서 서버와 연결을 실패하면 ConnectionException이 발생.
서버와의 작업이 끝나면 소켓과 스트림을 닫아야 한다.

Socket클래스에 정의된 getPort()와 getLocalPort()를 사용해서 TCP/IP통신에서
소켓이 사용하고 있는 포트를 알아낼 수 있다.
getPort()가 반환하는 값은 상대편 소켓이 사용하는 포트이고
getLocalPort()가 반환하는 값은 소켓 자신이 사용하는 포트이다.

ServerSocket클래스의 setSoTime(int timeout)을 사용해서 서버소켓의 대기시간을 지정할 수 있다.
timeout의 값은 천분의 일초단위이며 0을 입력하면 제한시간 없이 대기하게 된다.
지정한 대기시간이 지나면 accept()에서 SocketTimeouException이 발생.

서버에 접속하는 클라이언트의 수가 많을 때는 쓰레드를 이용해서 클라이언트의 요청을 병렬적으로 처리하는 것이 좋다.
그렇지 않으면 접속을 요청한 순서대로 처리하기 때문에 늦게 접속을 요청한 클라이언트는 오랜 시간을 기다릴 수 있다.

###2.3 UDP소켓 프로그래밍
TCP소켓 프로그래밍은 Socket과 ServerSocket을 사용,
UDP소켓 프로그래밍은 DatagramSocket과 DatagramPacket을 사용

DatagramPacket은 헤더와 데이터로 구성되어 있으며,
헤더에는 DatagramPacket을 수신할 호스트의 정보(호스트의 주소와 포트)가 저장되어 있다.

DatagramPacket을 전송하면 DatagramPacket에 지정된 주소의 DatagramSocket에 도착한다.